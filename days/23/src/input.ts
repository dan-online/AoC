const guideInput = `....#..
..###.#
#...#.#
.#...##
#.###..
##.#.##
.#..#..`;

const input = `.##.#.....##.#.......#..#####....#####...#..###..#.#..#...#.##...###.##.#
....##..##..........##.#..#.##...#.#.#...##..#..#####.#..#..#.#..#..####.
#.####.##..##.##.#####.#####...#.....#...####..##.##..###..##..#####..#..
..###.#.##....#.###.#..#####..##.####..###.####.######....###.#####...#..
#.#..#..#....#...####.#.....##..#.###.....##.#.#...#.#.##.######.#.#...##
....##..####..#.#...##....##.#.#...##..##..#....#..####.#.#########.....#
.#.###.##....#####.###..#.#......#.####.#....#.######.##..##...#####.##..
...######..##..#####.###.#.......##.#.#..######.###.##..#.##......#.##.#.
.#..######.#.##..##.#.###.####.#.#.#..##.###..#.##..#..#..#.###...#.#.###
.#.#.#...#.###..#..###.#.#...###.#####..#.##.#...#....###.##..#..#######.
####.#.###....###....#.#..##.......###.#.##.#....#..#........#..##...##.#
#..#...##.........#.#.####..####.####.#..####.....#....##..#..##.####...#
#...##..#...#..#.#.###.#.#.##..####....#######..####..#..#.##.#.####.##..
..##.##.##....#..##.###.#.#.#.#..####..##.#.#....##..###.#..#.#.#.#.....#
####.#.#..#..####.#.####.#.#..#...##...#.#..###.##......#....##.....##...
.#..##..##.....#.#.#.##..##..####.#.#.###.###.#...#..##....#...##..#.##..
#.#...#.##.#..#...#.##.#####...#..#..###....###...##.#.#...#.#######...##
#.##.#...#...###.###.#.######..##.####.#.###.##..#....#.#.#.#..#.#.####.#
.##.#.##.####.#.##..#.#.....##..##.#..#..#.#...####..#..#.#.#.....#####..
.#.#.#....#..##.##.####.###.#...###..#.#.#....##..##..#...#..##.#.##...##
###....#.#.##...###..##...#.#...#..#.###..#.###.##..#.....#.#.#.#.####...
##..##...###..##..###.###.##.######.##.......#..#....#.#.#..###.#.###.##.
#.#####..#####.....#.##.#.#..###..###.#...#.####.#.#.##.####.#.#..#....##
#.#.#...##...#.###..#.#####.#.##....#..#..##.##..###....#.####...##......
.....#.#####.....#.##...###.##.#..#.####.####........####.#.##..##.###.#.
.....#.###.#.#.##..##.###..###.#####......###..##....#.......##..#....#.#
###.#..#.##...#.###.#####.....#..####.####.###.....#.#..#....##.#...####.
#####.##.###.#.###.####....##.#.#.##....#.##.##......##.#.###..###.##.#.#
.###.##.#.#.#.#..#.#..#.##......##.#.###...#####..#.##.....#.#.##....##.#
#..###..#...#####..####...###.#.#.#.###.#..####..#.#.#....#.#.#.#...##.##
#..#.###.#....#....#..##.#..#......#..#.##.......#.#.#.#.####..#.##.##.##
..###.####.##..#...##.#..##.##.###......#..#.###..#..##.#..#####....#...#
.#.##..###...###.#..###.######.#...######..#..##.####.###.#.####..####.##
.#.###.##..##.####..####.#....####.###.###.##.##########.#...#.#....#....
.....#.#....###..#..##.##..###..#...#..##...##.##....##...#.##..##..#...#
.....##..#######...#..#..#.####.#.#...#...##...##.##.#...#..###.#...#.##.
..#.#####.#.#.#..##..#....########.##..#.#.###...#.####..#.......#..#...#
#.##....###.##..##.....#..##..###..###.#..#.#.##.#..#....#......#####.#.#
....#.##...#......####..#.####.#..#.#....#.#.#...##..##.##..#..#..##.#.#.
.##.#....#.#...#..##...##..#..#..##.#.#..##..#..#.##..#.....#####..##.#.#
##.#.########..#.#######..####.#..##..###.#..#.#.####.##.....#.#...#...#.
..#...#..##..#.##.###..####.###....#..#.........###..##..##.#..#...#.#.#.
.#.##....#.#..##.#..######.##..#...##....#.###..###.#.#..#.#.####..#...##
#.##.#.#.#.#..#.#..#####..#..#####...#..##..######.######.#.#..####....##
...##..#....##...##...#....#.##.....###.##....#..#...#.#.#..#..#..#..#..#
#.##..##.....#.#.##...#..##.#......#...#..#######.##..##....#.##..###..##
##...##..#...#.#.#..#.##.#.###.#..#..#######..######..#....###..#.#.###..
.....##.#....##..........#....##..#.##....##..#..#.###.#...##..##.#...##.
#.#.###.#.#..#..#..#.#.#..#..#.####..##..#..###.#..#..#.#.###..#.#..#....
#..##.#..##..#...#...#....#..#..###..##..#..#..#.#..#..#....#.#..####.##.
#..####.####.###.#..#..#..####..###..#..#.#.#..##..#..#......######.....#
#....####.....##..####....#....#.#...#..#.####...##.##.#.###..##.###.####
..####.#..#.####.##....##########....###.####.##..##......#.##.#..#..####
.#.#...#.#.##.##.....##..#....#.#...#.#..#...#..###..#....##..#....#.#.##
##....#.#......##..#.#.#......##...#...#.#..##...#....###.##....#.##.....
###.#..##.#.####....#...##.....###.....#..#.#...#.#.##....##.#..##.#.#..#
.#.##.#.....#.#######...#.##...##..###.#.#.##.####.....###..#.##.##.###.#
#.###.###..#######.#..#..##.####.###...####..#..###.#.##....#....##..####
#..##.###.#.#.####.##..##.##.#.#........##....#...###..#.###....##.......
.###.#.##..#.#..########....#.##........#.#.....#.#.##.#####.#..######...
#.#.#..###.##..###.#.##..##.#.#######...#...###.#.#.##..#..####..#..#####
#.####.##.#.###..##.#..##.....###.#######.###...######..##....#.#..#####.
.##.##.######.#..##...##..###..####...##....#.####.###.#...##..#####...##
####..#.####.#..###.#....##..#.#....##.#.###.....#...#..#..#..##...#..##.
.#.##.....##.#.#.#..#.#...##.#####...#...#..###...#..####.#...#..###...##
#.###.##...##.#.#..#.#.####...#.#.##..#.#..###.##.#..#..##.#.#.##.#..###.
#..####.#.#..##..#...#..#.#.#....#..#.#####.....#..#.....#.#.##.#.#..#.##
.#..###.#...#..#.#.####.#..#.#.#.....#...#.#.#..###...##.#..########.....
.#.#....##.###.#.#.#.######...#.#.######.#.#.####.##..#.#..#..####.#.#...
##.#.###.###.#####...##.#..#.####.#...#..#......###.##..##.#.#.....#..#..
.##....###.#.....###...####..#....#.#.#..#####.#.#..#.###..#.....#.#.###.
..#..#.#..##..#..#...#.#....#.##..##.######.###...##..#.#####...#.##.##..
.#.##.#..#..###...#####.##.....###.####...#...###....##.#.#.#..##...#..##`;

const i = process.argv.find((x) => x === '--prod') ? input : guideInput;

export enum Grid {
  Elf = '#',
  Empty = '.'
}

interface Coord {
  x: number;
  y: number;
}
type Directions = 'N' | 'NE' | 'E' | 'SE' | 'S' | 'SW' | 'W' | 'NW';

class Location {
  public x: number;
  public y: number;
  public type: Grid;

  public constructor(x: number, y: number, type: Grid) {
    this.x = x;
    this.y = y;
    this.type = type;
  }
}

class Area {
  public grid: Location[][];

  public checks: {
    fn: (d: { [key in Directions]?: { x: number; y: number } }) => boolean;
    pr: (e: Location) => { elf: Location; direction: Coord; goingTo: Coord };
  }[] = [
    {
      fn: (foundDirections) => (foundDirections.N && foundDirections.NE && foundDirections.NW ? true : false),
      pr: (elf) => ({ elf, direction: { x: 0, y: -1 }, goingTo: { x: elf.x, y: elf.y - 1 } })
    },
    {
      fn: (foundDirections) => (foundDirections.S && foundDirections.SE && foundDirections.SW ? true : false),
      pr: (elf) => ({ elf, direction: { x: 0, y: 1 }, goingTo: { x: elf.x, y: elf.y + 1 } })
    },

    {
      fn: (foundDirections) => (foundDirections.W && foundDirections.NW && foundDirections.SW ? true : false),
      pr: (elf) => ({ elf, direction: { x: -1, y: 0 }, goingTo: { x: elf.x - 1, y: elf.y } })
    },
    {
      fn: (foundDirections) => (foundDirections.E && foundDirections.NE && foundDirections.SE ? true : false),
      pr: (elf) => ({ elf, direction: { x: 1, y: 0 }, goingTo: { x: elf.x + 1, y: elf.y } })
    }
  ];

  public constructor(grid: Location[][]) {
    this.grid = grid;
  }

  public get output() {
    return this.grid.map((x) => x.map((y) => y.type).join('')).join('\n');
  }

  public get elfs() {
    return this.grid.flatMap((x) => x.filter((x) => x.type === Grid.Elf));
  }

  public removeEmptyOutside() {
    // remove empty rows from top and bottom
    while (this.grid[0].every((x) => x.type === Grid.Empty)) {
      this.grid.shift();

      this.grid = this.grid.map((x) => x.map((loc) => new Location(loc.x, loc.y - 1, loc.type)));
    }

    while (this.grid[this.grid.length - 1].every((x) => x.type === Grid.Empty)) {
      this.grid.pop();
    }

    // remove empty columns from left and right
    while (this.grid.every((x) => x[0].type === Grid.Empty)) {
      this.grid = this.grid.map((x) => x.slice(1).map((x) => new Location(x.x - 1, x.y, x.type)));
    }

    while (this.grid.every((x) => x[x.length - 1].type === Grid.Empty)) {
      this.grid = this.grid.map((x) => x.slice(0, x.length - 1));
    }
  }

  public increaseArea() {
    this.grid = this.grid.map((line, i) => [
      new Location(0, i, Grid.Empty),
      ...line.map((loc) => new Location(loc.x + 1, loc.y, loc.type)),
      new Location(line.length + 1, 0, Grid.Empty)
    ]);

    this.grid = [
      new Array(this.grid[0].length).fill('').map((_, i) => new Location(i, 0, Grid.Empty)),
      ...this.grid.map((line) => line.map((loc) => new Location(loc.x, loc.y + 1, loc.type))),
      new Array(this.grid[0].length).fill('').map((_, i) => new Location(i, this.grid.length + 1, Grid.Empty))
    ];
  }

  public moveProposals() {
    const proposals: { elf: Location; direction: { x: number; y: number }; goingTo: { x: number; y: number } }[] = [];

    this.increaseArea();
    for (const elf of this.elfs) {
      // look in all 8 directions to check for another elf
      const directions: { x: number; y: number; direction: Directions }[] = [
        { x: -1, y: 1, direction: 'SW' },
        { x: 0, y: 1, direction: 'S' },
        { x: 1, y: 1, direction: 'SE' },
        { x: -1, y: 0, direction: 'W' },
        { x: 1, y: 0, direction: 'E' },
        { x: -1, y: -1, direction: 'NW' },
        { x: 0, y: -1, direction: 'N' },
        { x: 1, y: -1, direction: 'NE' }
      ];

      const foundDirections: { [key in Directions]?: { x: number; y: number } } = {};

      for (const direction of directions) {
        const target = this.grid[elf.y + direction.y][elf.x + direction.x]!;

        if (target.type === Grid.Empty) {
          foundDirections[direction.direction] = { x: target.x, y: target.y };
        }
      }

      const values = Object.values(foundDirections);

      if (values.length === directions.length) {
        continue;
      }

      for (const check of this.checks) {
        if (check.fn(foundDirections)) {
          proposals.push(check.pr(elf));
          break;
        }
      }
    }

    return proposals;
  }

  public moveElfs(proposals: { elf: Location; direction: { x: number; y: number }; goingTo: { x: number; y: number } }[]) {
    const allowed = [];
    let movements = 0;

    for (const proposal of proposals) {
      // each Elf moves to their proposed destination tile if they were the only Elf to propose moving to that position. If two or more Elves propose moving to the same position, none of those Elves move.
      const elfsToSpot = proposals.filter((x) => x.goingTo.x === proposal.goingTo.x && x.goingTo.y === proposal.goingTo.y);

      if (elfsToSpot.length > 1) {
        continue;
      }

      allowed.push(proposal);
    }

    for (const proposal of allowed) {
      const { elf } = proposal;
      const { goingTo } = proposal;

      this.grid[elf.y][elf.x] = new Location(elf.x, elf.y, Grid.Empty);
      this.grid[goingTo.y][goingTo.x] = new Location(goingTo.x, goingTo.y, Grid.Elf);
      movements++;
    }

    return movements;
  }

  public round() {
    const proposals = this.moveProposals();
    const movements = this.moveElfs(proposals);

    this.checks = [...this.checks.slice(1), this.checks[0]];
    this.removeEmptyOutside();

    return movements;
  }
}

export const getArea = () => {
  const grid: Grid[][] = i.split('\n').map((x) => x.split('') as Grid[]);
  const areaGrid: Location[][] = [];

  for (let y = 0; y < grid.length; y++) {
    const row: Location[] = [];

    for (let x = 0; x < grid[y].length; x++) {
      row.push(new Location(x, y, grid[y][x]));
    }

    areaGrid.push(row);
  }

  return new Area(areaGrid);
};
